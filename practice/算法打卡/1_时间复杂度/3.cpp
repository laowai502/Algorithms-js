i = 1;
while (i <= n)
{
    i = i * 2;
}

// O(logN)

// 从代码中可以看出变量 i 的值从 1 开始取，
// 每循环一次就乘以2，当等于 n 时，循环结束。
// 参考高中时期的等比数列，实际上变量 i 的取值就是一个等比数列
// 如果把它一个一个列出来，就应该是这个样子的

// 所以，我们只知道 x 值是多少，就知道这行代码执行的次数了。
// 通过 2x = n 求解 x = log2n，所以时间复杂度为 O(log2n)

i = 1;
while (i <= n)
{
    i = i * 3;
}
/**
 * 根据刚刚的思路，这段代码的时间复杂度为 O(log3n)。
 * 实际上，不管是以2为底，以3为底，还是以10为底，我们可以把所有对数阶的时间复杂度都标记为 O(logN)。
 * 为什么呢？我们知道，对数之间是可以相互转换的，log3n = log32 * log2n, 所以 O(log3n) = O(C * log2n).
 * 其中 C = log32 是一个常量。基于我们面前的理论：在采用大O表示法标记复杂度时，可以忽略系数
 * 因此在对数阶时间复杂度的表示法里，我们忽略对数的底，统一表示为 O(logN) 
 * 对于 O(nlogN) 就很好理解了，如果一段代码的时间复杂度时 O(logN), 那我们循环执行 n 遍，时间复杂度就是 O(nlogN)
 * 而且 O(nlogN) 也是一种常见的算法时间复杂度称为 线性对数阶
 * eg: 归并排序，快速排序的时间复杂度就是 O(nlogN)
*/